#include "encryption.h"

#include <cmath>

namespace secureagg {
BEPublicKey::BEPublicKey(PtxSpace ptx_mod, NTL::ZZ&& ctx_mod, NTL::ZZ&& gen)
    : ptx_mod_{std::move(ptx_mod)},
      ctx_mod_{std::move(ctx_mod)},
      gen_(std::move(gen)) {}

PtxSpace BEPublicKey::plaintextModulus() const { return ptx_mod_; }

const NTL::ZZ& BEPublicKey::ciphertextModulus() const { return ctx_mod_; }

const NTL::ZZ& BEPublicKey::ptxSubGrpGen() const { return gen_; };

void BEPublicKey::sampleRand(NTL::ZZ& rand) const {
  do {
    RandomBnd(rand, ctx_mod_);
  } while (NTL::GCD(rand, ctx_mod_) != 1);
}

NTL::ZZ BEPublicKey::sampleRand() const {
  NTL::ZZ rand;
  sampleRand(rand);
  return rand;
}

void BEPublicKey::sampleRand(NTL::ZZ& rand, NTL::RandomStream& stream) const {
  // Swap the current random stream with the input stream.
  auto prev_stream = NTL::GetCurrentRandomStream();
  NTL::SetSeed(stream);

  sampleRand(rand);

  // Update stream and switch current random stream to previous stream.
  stream = NTL::GetCurrentRandomStream();
  NTL::SetSeed(prev_stream);
}

NTL::ZZ BEPublicKey::sampleRand(NTL::RandomStream& stream) const {
  NTL::ZZ rand;
  sampleRand(rand, stream);
  return rand;
}

void BEPublicKey::encrypt(NTL::ZZ& ctx, PtxSpace val,
                          const NTL::ZZ& rand) const {
  NTL::PowerMod(ctx, rand, ptx_mod_, ctx_mod_);
  NTL::MulMod(ctx, NTL::PowerMod(gen_, val, ctx_mod_), ctx, ctx_mod_);
}

NTL::ZZ BEPublicKey::encrypt(PtxSpace val, const NTL::ZZ& rand) const {
  NTL::ZZ ctx;
  encrypt(ctx, val, rand);
  return ctx;
}

void BEPublicKey::encrypt(NTL::ZZ& ctx, PtxSpace val) const {
  auto rand = sampleRand();
  encrypt(ctx, val, rand);
}

NTL::ZZ BEPublicKey::encrypt(PtxSpace val) const {
  NTL::ZZ ctx;
  encrypt(ctx, val);
  return ctx;
}

void BEPublicKey::sampleCiphertext(NTL::ZZ& ctx) const {
  return sampleRand(ctx);
}

NTL::ZZ BEPublicKey::sampleCiphertext() const { return sampleRand(); }

void BEPublicKey::sampleCiphertext(NTL::ZZ& ctx,
                                   NTL::RandomStream& stream) const {
  sampleRand(ctx, stream);
}

NTL::ZZ BEPublicKey::sampleCiphertext(NTL::RandomStream& stream) const {
  return sampleRand(stream);
}

void BEPublicKey::poly_eval(NTL::ZZ& output,
                            const std::vector<NTL::ZZ>& coeff_ctx,
                            PtxSpace pt) const {
  NTL::set(output);

  // Use Horner's method to evaluate the polynomial.
  // TODO: Is there a more efficient alternative?
  for (auto i = coeff_ctx.rbegin(); i != coeff_ctx.rend(); i++) {
    NTL::PowerMod(output, output, pt, ctx_mod_);
    NTL::MulMod(output, output, *i, ctx_mod_);
  }
}

NTL::ZZ BEPublicKey::poly_eval(const std::vector<NTL::ZZ>& coeff_ctx,
                               PtxSpace pt) const {
  NTL::ZZ output{1};
  poly_eval(output, coeff_ctx, pt);
  return output;
}

BruteForceDL::BruteForceDL(const NTL::ZZ& base, NTL::ZZ&& mod, PtxSpace order,
                           double space_param)
    : mod_{std::move(mod)},
      order_{std::move(order)},
      num_entries_(
          static_cast<PtxSpace>(std::ceil(std::pow(order_, space_param)))) {
  // Build look-up table
  NTL::ZZ acc{1};
  for (PtxSpace i = 0; i < num_entries_; i++) {
    lookup_.emplace(acc, i);
    acc = NTL::MulMod(acc, base, mod_);
  }

  // Compute jump for using lookup table
  NTL::PowerMod(jump_, base, -1 * num_entries_, mod_);
  num_jumps_ = order_ / num_entries_;
}

PtxSpace BruteForceDL::operator()(const NTL::ZZ& val) const {
  NTL::ZZ v;

  // Search for discrete-log using look-up table
  // TODO: Will multi-threading improve performance?
  for (NTL::ZZ i{0}, acc{1}; i <= num_jumps_; i++) {
    NTL::MulMod(v, acc, val, mod_);

    if (auto j = lookup_.find(v); j != lookup_.end()) {
      // Reduce discrete-log by order_ before returning
      return (i * num_entries_ + j->second) % order_;
    }

    acc = NTL::MulMod(acc, jump_, mod_);
  }

  throw std::domain_error(
      "Input is not in subgroup generated by base element.");
}

void BESecretKey::genCiphertextModulus(uint32_t num_bits_ctx_mod) {
  uint32_t num_prime_bits = (num_bits_ctx_mod + 1) / 2;
  uint32_t num_bits_ptx_mod = NTL::NumBits(ptx_mod_);

  // Sample first prime factor.
  // factor1_ should be such that the ptx_mod_ does not divide factor1_ - 1.
  PtxSpace offset = 0;
  do {
    NTL::RandomBnd(offset, ptx_mod_);
  } while ((offset == 0) || (offset == 1));

  NTL::ZZ mult;
  uint32_t len_mult = num_prime_bits - num_bits_ptx_mod + 1;
  do {
    NTL::RandomLen(mult, len_mult);
    factor1_ = ptx_mod_ * mult + offset;
  } while (!NTL::ProbPrime(factor1_));

  // Sample second prime factor.
  // factor2_ should be such that ptx_mod_ divides factor2_ - 1 but ptx_mod_^2
  // does not divide factor2_ - 1.
  do {
    NTL::RandomBnd(offset, ptx_mod_);
  } while (offset == 0);

  len_mult = num_prime_bits - 2 * num_bits_ptx_mod + 2;
  do {
    NTL::RandomLen(mult, len_mult);
    factor2_ = ptx_mod_ * ptx_mod_ * mult + offset * ptx_mod_ + 1;
  } while (!NTL::ProbPrime(factor2_));

  // Compute ciphertext modulus
  ctx_mod_ = factor1_ * factor2_;
}

void BESecretKey::genKey(double space_param) {
  auto phi_by_ptx_mod = ((factor1_ - 1) * (factor2_ - 1)) / ptx_mod_;

  // Compute gen_ as a "non ptx_mod_ residue" mod ctx_mod_
  do {
    RandomBnd(gen_, ctx_mod_);
  } while ((NTL::GCD(gen_, ctx_mod_) != 1) ||
           (NTL::PowerMod(gen_, phi_by_ptx_mod, ctx_mod_) == 1));

  // Compute the decryption key/exponent
  NTL::ZZ gcd, bezout_ptx_mod, bezout_phi_by_ptx_mod;
  NTL::XGCD(gcd, bezout_ptx_mod, bezout_phi_by_ptx_mod, NTL::ZZ(ptx_mod_),
            phi_by_ptx_mod);
  dec_exp_ = bezout_phi_by_ptx_mod * phi_by_ptx_mod;

  NTL::ZZ base;
  NTL::PowerMod(base, gen_, dec_exp_, ctx_mod_);

  dlog_.emplace(base, NTL::ZZ(ctx_mod_), ptx_mod_, space_param);
}

BESecretKey::BESecretKey(PtxSpace ptx_mod, uint32_t num_bits_ctx_mod,
                         double space_param)
    : ptx_mod_{std::move(ptx_mod)} {
  genCiphertextModulus(num_bits_ctx_mod);
  genKey(space_param);
}

PtxSpace BESecretKey::plaintextModulus() const { return ptx_mod_; }

const NTL::ZZ& BESecretKey::ptxSubGrpGen() const { return gen_; };

const NTL::ZZ& BESecretKey::ciphertextModulus() const { return ctx_mod_; }

const NTL::ZZ& BESecretKey::ctxModulusFactor1() const { return factor1_; }

const NTL::ZZ& BESecretKey::ctxModulusFactor2() const { return factor2_; }

BEPublicKey BESecretKey::getPublicKey() const {
  return BEPublicKey(ptx_mod_, NTL::ZZ(ctx_mod_), NTL::ZZ(gen_));
}

PtxSpace BESecretKey::decrypt(const NTL::ZZ& ctx) const {
  auto canonical_root = NTL::PowerMod(ctx, dec_exp_, ctx_mod_);
  return (*dlog_)(canonical_root);
}
}  // namespace secureagg
